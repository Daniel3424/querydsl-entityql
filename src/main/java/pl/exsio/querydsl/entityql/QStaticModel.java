package pl.exsio.querydsl.entityql;

import com.querydsl.core.dml.StoreClause;
import com.querydsl.core.types.Path;
import com.querydsl.sql.ForeignKey;
import pl.exsio.querydsl.entityql.ex.InvalidArgumentException;

import java.util.HashMap;
import java.util.Map;

/**
 * Parent Class of all Static Models generated by EntityQL. Contains some convenience methods.
 *
 * @param <E> - source Entity Type
 */
public class QStaticModel<E> extends QBase<E> {

    protected final Map<String, Path<?>> columnsMap = new HashMap<>();
    protected final Map<String, ForeignKey<?>> joinColumnsMap = new HashMap<>();

    public QStaticModel(Class<? extends E> type, String variable, String schema, String table) {
        super(type, variable, schema, table);
    }

    /**
     * Convenience method used to quiclky set values on insert/update/merge clauses.
     * Method requires the 'params' parameter to be of even size.
     * Every other params array item has to be a Path
     * <p>
     * Example:
     * <p>
     * QBook book = QBook.INSTANCE;
     * book.set(
     * queryFactory.insert(book),
     * book.id, 11L,
     * book.name, "newBook2",
     * book.price, BigDecimal.ONE
     * ).execute();
     *
     * @param clause - insert/update/merge clause
     * @param params - varargs array with parameters
     * @return clause from the 1st argument
     */
    @SuppressWarnings(value = "unchecked")
    public <C extends StoreClause<C>> StoreClause<C> set(StoreClause<C> clause, Object... params) {
        if (params.length % 2 != 0) {
            throw new InvalidArgumentException("Odd number of parameters");
        }
        for (int i = 0; i < params.length - 1; i += 2) {
            Object key = params[i];
            Object value = params[i + 1];
            if (!(key instanceof Path)) {
                throw new InvalidArgumentException("Param key has to be Path");
            }
            clause.set((Path<Object>) key, value);
        }
        return clause;
    }

    /**
     * Convenience method to obtain a corresponding Dynamic Query Model
     *
     * @return Dynamic Q-Model for corresponding Static Model
     */
    @SuppressWarnings(value = "unchecked")
    public Q<E> dynamic() {
        Class<E> type = (Class<E>) getType();
        return EntityQL.qEntity(type);
    }

    /**
     * Convenience method to obtain a corresponding Dynamic Query Model
     * <p>
     * Variables are serving as Table Aliases in generated SQL Statements
     * Default variable is always equal to the table name itself.
     * Custom variable is handy if we want to use the same Table multiple
     * times in the same SQL query.
     *
     * @param variable - custom variable name
     * @return Dynamic Q-Model for corresponding Static Model
     */
    @SuppressWarnings(value = "unchecked")
    public Q<E> dynamic(String variable) {
        Class<E> type = (Class<E>) getType();
        return EntityQL.qEntity(type, variable);
    }

    /**
     * Returns Path<R> Expression for given Column Field name
     *
     * @throws InvalidArgumentException if the Column Field of that name doesn't exist in the current Model
     * @throws ClassCastException if the resulting Expression cannot be casted to Path<T>
     * @param fieldName - entity Field name
     * @return - corresponding Path<R> expressions
     */
    @SuppressWarnings(value = "unchecked")
    public <R> R column(String fieldName) {
        Path<?> column = columnsMap.get(fieldName);
        if (column == null) {
            throw new InvalidArgumentException(String.format("There is no Column with Name '%s'", fieldName));
        }
        return (R) column;
    }

    /**
     * Returns ForeignKey<R> Expression for given JoinColumn Field name
     *
     * @throws InvalidArgumentException if the JoinColumn Field of that name doesn't exist in the current Model
     * @param fieldName - entity Field name
     * @return - corresponding ForeignKey<R> expressions
     */
    @SuppressWarnings(value = "unchecked")
    public <R> ForeignKey<R> joinColumn(String fieldName) {
        ForeignKey<?> joinColumn = joinColumnsMap.get(fieldName);
        if (joinColumn == null) {
            throw new InvalidArgumentException(String.format("There is no Join Column with Name '%s'", fieldName));
        }
        return (ForeignKey<R>) joinColumn;
    }

    /**
     *
     * @return Map of All Columns with their respective Java Names as keys
     */
    public Map<String, Path<?>> columns() {
        return columnsMap;
    }

    /**
     *
     * @return Map of All JOin Columns with their respective Java Names as keys
     */
    public Map<String, ForeignKey<?>> joinColumns() {
        return joinColumnsMap;
    }

    /**
     *
     * @param fieldName - entity Field name
     * @return - true if current model contains a Column corresponding to the fieldName
     */
    public boolean containsColumn(String fieldName) {
        return columnsMap.containsKey(fieldName);
    }

    /**
     *
     * @param fieldName - entity Field name
     * @return - true if current Model contains a JoinColumn corresponding to the fieldName
     */
    public boolean containsJoinColumn(String fieldName) {
        return joinColumnsMap.containsKey(fieldName);
    }
}
